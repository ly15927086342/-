Author: _Yu Li_  
date: _2020/04/17_  
  
# 网络协议相关总结  
  
## 题目  
  
1. AJAX  
XmlHttpRequest对象的封装，可以异步请求  
  
2. GET和POST的异同  
相同：都是HTTP方法，基于TCP/IP协议  
不同：1.GET明文，POST密文 2.GET长度有限 3.GET ASCII码，中文要编码 4.GET有一个包，header和data一起发，200返回；POST有两个包，先header，100了再发data，200返回 

`补充`：
就安全性来说，post和get其实差不多，url和body都可以被劫持，最好是用https来保证安全性；  
编码不同更多是针对url和body的编码方式而言，post和get其实都可以带url和body。url的编码只能是ASCII（RFC1738定义），body由Content-Type定义，例如application/x-www-form-urlencoded等；  
post之所以发两次请求，是因为body的数据有可能过大，先把请求头发过去，返回100后再把body发过去；  

3. 同源策略(CORS)：更重要的安全策略，限制脚本与其他源进行交互，阻隔恶意文档，减少可能被攻击的媒介  
同源定义：（协议、端口、主机）  
document.domain可改为父域，如A.mm.com->mm.com，然后访问子域名属于同源  
  
4. JSONP原理  
script标签可跨域，加回调有参数返回，但有安全隐患  
具体做法是`服务端要在返回数据外层包裹一个客户端定义好的函数（callback）`
  
5. 跨域：解决获取不同源对象问题  
法一：JSONP（GET）  
法二：空iframe+form（POST）  
法三：CORS，简单请求origin:* ; 非简单请求前端withCredentials后端Credentials\origin指定\method\Headers，Allow-Access-Control-...  
法四：代理Nginx  
  
6. HTTP常见状态码：200 301 302 404 403 500  
1开头：临时响应，继续执行  
2开头：成功  
3开头：重定向（需进一步操作）  
4开头：请求错误  
5开头：服务器错误  
301：永久移动  
302：临时移动  
403：禁止访问  
404：未找到资源  
500：内部错误  
  
7. 浏览器缓存  
1.强制缓存  
cache-control：no-cache\no-store\max-age  
设置了cache-control，Expires就会被忽略  
`no-cache含义是不缓存过期资源(每次请求访问服务器，服务器验证是否过期，判断可否使用缓存)`
`no-store含义是不缓存（每次请求都必须访问服务器的资源）`
`public请求路径上都可以对资源进行缓存`
`private只有发出请求的浏览器才可以缓存`
`max-age最大缓存时长，没过期直接使用缓存`
2.协商缓存  
Etag/Last-Modified区别  
Etag：第一次请求，返回ETag（MD5由文件内容生成）  
第二次请求，请求头带If-None-Match: MD5(不一定是hash算的，太慢了)  
若两次MD5不同，则重新返回资源，  
若一致，则返回状态码304  

ETag计算：
强ETag根据文件的inode,mtime和size生成  
弱ETag根据文件的mtime生成（精度：秒）
  
Last-Modified：第一次请求，返回上次修改时间（精度：秒）  
第二次请求，带头If-modified-since：时间  
如果一致，则表明未修改，返回304  
如果不一致，返回资源  
  
`强制缓存和协商缓存的区别：`  
强制缓存在浏览器端判断资源是否在效期内，如果过期，则往后端发请求  
协商缓存会往后端发请求，来判断是否更新，然后返回资源或304  
  
8. TCP和UDP区别  

|TCP|UDP|  
|:--|:--|  
|连接|无连接|  
|对系统要求多|要求少|  
|复杂|结构简单|  
|流模式|数据报模式|  
|保证数据正确|可能丢包|  
|保证数据顺序|无法保证|  
|重量级|轻量|  
|可靠性高（SYN/ACK和重传机制）|可靠性低，传输流量大，传输速度快|
|金融等大多数领域|游戏、娱乐、视频等|
  
  
9. AJAX发送http请求的过程  
（1）创建XMLHttpRequest对象xhr  
（2）设置请求参数open，包括请求方法、url和同步/异步  
（3）发送请求send  
（4）注册状态监听事件onreadystatechange  
（5）接收返回数据xhr.responseText  

onreadystatechange事件中  
`xhr.readyState`包含：  
0：请求未初始化  
1：服务器已建立连接  
2：请求已接收  
3：请求处理中  
4：请求已完成，且响应已就绪  
`xhr.status`包含：  
200："OK"  
404：没找到页面  

10. HTTP2.0和HTTP1.1区别

(1)新的二进制格式（Binary Format）http协议解析基于二进制  
(2)多路复用（MultiPlexing）一个链接多个请求并行  
(3)header压缩，双方cache一份header fields表  
(4)服务端推送（server push）　

11. 请求头Host、Origin、Referer

Host：请求主机的地址  
Origin：当前网站的域名  
Referer：当前网站的完整地址

12. CDN(Content Delivery Network)内容分发网络

浏览器访问链接-》

访问本地DNS服务器，如果有ip则返回，如果没有-》

根据CNAME找到CDN专用的DNS服务器-》

CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户-》

用户向全局负载均衡设备发起URL请求－》

全局负载均衡设备根据用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上-》

区域负载均衡设备选择最优的缓存服务器，从该服务器节点处得到缓存服务器的IP地址，最终将得到的IP地址返回给全局负载均衡设备

13. 301和302区别

301是永久重定向，除非浏览器手动清除缓存，不然是会永久缓存的  
302是临时重定向，浏览器是不会缓存的（因为如果一旦缓存，重定向的地址改变，就始终使用旧的缓存内容）  

缓存的是整个报文，301缓存会缓存旧URL和旧的报文。浏览器重定向location的url地址，个人认为新的url和新的报文也会缓存，状态码估计是200？（不确定）  

14. Ajax如何写重定向？  
只有浏览器搜索栏的url是重定向，才会自动重定向，Ajax的重定向需要自己处理。  
在`complete事件`中写  
```javascript
$.ajax({
	url : '/test.php',
	dataType : 'json',
	complete : function(xhr){
		if((xhr.status >= 300 && xhr.status < 400) && xhr.status != 304){
			//重定向网址在响应头中，取出再执行跳转
			var redirectUrl = xhr.getResponseHeader('X-Redirect');
			location.href = redirectUrl;
		}
	},
	success : function(result){
		console.log('收到预期的json数据');
	}
});
```

15. ajax和axios区别

相同：
（1）两者都是基于XMLHttpRequest
（2）都可以全局配置

不同：  
（1）ajax是jquery的一部分，体积很大，axios体积相对小
（2）ajax参数都写在一个对象中，包括回调，而axios是promise的写法，有then和catch
（3）ajax支持同步和异步，axios只支持异步，但是用链式调用，可以间接达到同步效果
（4）ajax不支持并发请求，axios支持，通过axios.all和axios.spread实现
（5）axios支持防止CSRF攻击，通过配置
等等  

16. 浏览器有多个请求的网络情况

HTTP1.1一个tcp连接可以有多个http请求，但是这些请求是串行的，当有多个http请求时，为了尽可能不被阻塞，浏览器是可以建立多条tcp连接的。如Chrome对于同一个Host，最多可以建立6条tcp连接。

17. 为什么要进行三次握手？三次握手的作用是什么？

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

18. 为什么要四次挥手？

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就
会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

19. 拥塞控制

[https://zhuanlan.zhihu.com/p/37379780](https://zhuanlan.zhihu.com/p/37379780)
![/static/imgs/TCP拥塞控制示意图.jpg](/static/imgs/TCP拥塞控制示意图.jpg)

20. 流量控制

**什么是流量控制？流量控制的目的？**

如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。

**如何实现流量控制？**

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

**流量控制引发的死锁？怎么避免死锁的发生？**

当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。
为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。

21. TCP可靠性如何保证？  
TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度（MSS）、滑动窗口控制、拥塞控制等方法实现了可靠性传输。

首先，TCP需要解决数据的`破坏`、`丢包`、`重复`以及`分片顺序混乱`等问题。

`序列号和确认应答（ACK）`：

通过TCP首部的序列号和数据长度可以计算下一次要接收的序列号，作为确认应答（ACK）返送回去。  
发送方接收到ACK，可以确认上一次的数据已经发送成功。

`超时重传`：

一定时间内发送方没有收到ACK，则需要重新发送上一轮的数据。  
如果重传超过一定次数，也没有收到ACK，则关闭连接（RST）。

`最大消息长度`：

TCP会将数据以MSS长度进行分割，然后发送。  
MSS在三次握手时，会取两端主机的MSS最小值，即能接收的数据包大小。

`滑动窗口控制（流控制）`：

窗口大小是指无需等待确认应答而可以继续发送数据的最大值。  
由于部分数据可能丢失ACK，所以在没有收到ACK之前必须缓存原数据，接收ACK之后即可删除缓存。  
收到ACK后，窗口会滑动到ACK中的序列号位置，重新发送下一轮数据。  
如果一个主机连续3次收到同一个确认应答，就会将对应的数据进行重发（高速重发控制）。  
窗口的大小是动态变化的（流控制），根据接收方的实际接收能力（剩余缓存空间）控制发送的数据量（窗口大小）。  
为了防止发生死锁（发送方和接收方都处于等待状态），如果发送方收到窗口为0的ACK，就会先等待，然后一段时间就发送一个窗口探测的包，如果收到窗口不为0的ACK，则继续发送对应的数据包。

`拥塞控制`：

解决网络拥塞问题。　　
先慢启动，指数式增大窗口，当遇到超时没有接收ACK，则以该窗口大小的二分之一作为慢启动阈值，然后重新开始慢启动，达到阈值后，窗口改为线性增长，如果重复确认应答（至少３次），则慢启动阈值修改为当前窗口的二分之一，窗口大小调整到阈值，然后继续线性增长。

总结：如果超时没收到ACK，则重新慢启动；如果重复接收到相同ACK至少3次，则调整到阈值继续线性增长。

综上，流控制是根据接受方的接收能力来控制窗口大小；而拥塞控制是考虑网络拥塞状况来调节窗口大小`（取接收方返回的窗口和拥塞窗口的最小值作为实际的窗口大小）`。