Author: _Yu Li_  
date: _2020/04/17_  
  
# 网络协议相关总结  
  
## 题目  
  
1. AJAX  
XmlHttpRequest对象的封装，可以异步请求  
  
2. GET和POST的异同  
相同：都是HTTP方法，基于TCP/IP协议  
不同：1.GET明文，POST密文 2.GET长度有限 3.GET ASCII码，中文要编码 4.GET有一个包，header和data一起发，200返回；POST有两个包，先header，100了再发data，200返回 

`补充`：
就安全性来说，post和get其实差不多，url和body都可以被劫持，最好是用https来保证安全性；  
编码不同更多是针对url和body的编码方式而言，post和get其实都可以带url和body。url的编码只能是ASCII（RFC1738定义），body由Content-Type定义，例如application/x-www-form-urlencoded等；  
post之所以发两次请求，是因为body的数据有可能过大，先把请求头发过去，返回100后再把body发过去；  

3. 同源策略(CORS)：更重要的安全策略，限制脚本与其他源进行交互，阻隔恶意文档，减少可能被攻击的媒介  
同源定义：（协议、端口、主机）  
document.domain可改为父域，如A.mm.com->mm.com，然后访问子域名属于同源  
  
4. JSONP原理  
script标签可跨域，加回调有参数返回，但有安全隐患  
具体做法是`服务端要在返回数据外层包裹一个客户端定义好的函数（callback）`
  
5. 跨域：解决获取不同源对象问题  
法一：JSONP（GET）  
法二：空iframe+form（POST）  
法三：CORS，简单请求origin:* ; 非简单请求前端withCredentials后端Credentials\origin指定\method\Headers，Allow-Access-Control-...  
法四：代理Nginx  
  
6. HTTP常见状态码：200 301 302 404 403 500  
1开头：临时响应，继续执行  
2开头：成功  
3开头：重定向（需进一步操作）  
4开头：请求错误  
5开头：服务器错误  
301：永久移动  
302：临时移动  
403：禁止访问  
404：未找到资源  
500：内部错误  
  
7. 浏览器缓存  
1.强制缓存  
cache-control：no-cache\no-store\max-age  
设置了cache-control，Expires就会被忽略  
`no-cache含义是不缓存过期资源(每次请求访问服务器，服务器验证是否过期，判断可否使用缓存)`
`no-store含义是不缓存（每次请求都必须访问服务器的资源）`
`public请求路径上都可以对资源进行缓存`
`private只有发出请求的浏览器才可以缓存`
`max-age最大缓存时长，没过期直接使用缓存`
2.协商缓存  
Etag/Last-Modified区别  
Etag：第一次请求，返回ETag（MD5由文件内容生成）  
第二次请求，请求头带If-None-Match: MD5(不一定是hash算的，太慢了)  
若两次MD5不同，则重新返回资源，  
若一致，则返回状态码304  

ETag计算：
强ETag根据文件的inode,mtime和size生成  
弱ETag根据文件的mtime生成（精度：秒）
  
Last-Modified：第一次请求，返回上次修改时间（精度：秒）  
第二次请求，带头If-modified-since：时间  
如果一致，则表明未修改，返回304  
如果不一致，返回资源  
  
`强制缓存和协商缓存的区别：`  
强制缓存在浏览器端判断资源是否在效期内，如果过期，则往后端发请求  
协商缓存会往后端发请求，来判断是否更新，然后返回资源或304  
  
8. TCP和UDP区别  

|TCP|UDP|  
|:--|:--|  
|连接|无连接|  
|对系统要求多|要求少|  
|复杂|结构简单|  
|流模式|数据报模式|  
|保证数据正确|可能丢包|  
|保证数据顺序|无法保证|  
|重量级|轻量|  
|可靠性高（SYN/ACK和重传机制）|可靠性低，传输流量大，传输速度快|
|金融等大多数领域|游戏、娱乐、视频等|
  
  
9. AJAX发送http请求的过程  
（1）创建XMLHttpRequest对象xhr  
（2）设置请求参数open，包括请求方法、url和同步/异步  
（3）发送请求send  
（4）注册状态监听事件onreadystatechange  
（5）接收返回数据xhr.responseText  

onreadystatechange事件中  
`xhr.readyState`包含：  
0：请求未初始化  
1：服务器已建立连接  
2：请求已接收  
3：请求处理中  
4：请求已完成，且响应已就绪  
`xhr.status`包含：  
200："OK"  
404：没找到页面  

10. HTTP2.0和HTTP1.1区别

(1)新的二进制格式（Binary Format）http协议解析基于二进制  
(2)多路复用（MultiPlexing）一个链接多个请求并行  
(3)header压缩，双方cache一份header fields表  
(4)服务端推送（server push）　

11. 请求头Host、Origin、Referer

Host：请求主机的地址  
Origin：当前网站的域名  
Referer：当前网站的完整地址

12. CDN(Content Delivery Network)内容分发网络

浏览器访问链接-》

访问本地DNS服务器，如果有ip则返回，如果没有-》

根据CNAME找到CDN专用的DNS服务器-》

CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户-》

用户向全局负载均衡设备发起URL请求－》

全局负载均衡设备根据用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上-》

区域负载均衡设备选择最优的缓存服务器，从该服务器节点处得到缓存服务器的IP地址，最终将得到的IP地址返回给全局负载均衡设备

13. 301和302区别

301是永久重定向，除非浏览器手动清除缓存，不然是会永久缓存的  
302是临时重定向，浏览器是不会缓存的（因为如果一旦缓存，重定向的地址改变，就始终使用旧的缓存内容）  

缓存的是整个报文，301缓存会缓存旧URL和旧的报文。浏览器重定向location的url地址，个人认为新的url和新的报文也会缓存，状态码估计是200？（不确定）  

14. Ajax如何写重定向？  
只有浏览器搜索栏的url是重定向，才会自动重定向，Ajax的重定向需要自己处理。  
在`complete事件`中写  
```javascript
$.ajax({
	url : '/test.php',
	dataType : 'json',
	complete : function(xhr){
		if((xhr.status >= 300 && xhr.status < 400) && xhr.status != 304){
			//重定向网址在响应头中，取出再执行跳转
			var redirectUrl = xhr.getResponseHeader('X-Redirect');
			location.href = redirectUrl;
		}
	},
	success : function(result){
		console.log('收到预期的json数据');
	}
});
```

15. ajax和axios区别

相同：
（1）两者都是基于XMLHttpRequest
（2）都可以全局配置

不同：  
（1）ajax是jquery的一部分，体积很大，axios体积相对小
（2）ajax参数都写在一个对象中，包括回调，而axios是promise的写法，有then和catch
（3）ajax支持同步和异步，axios只支持异步，但是用链式调用，可以间接达到同步效果
（4）ajax不支持并发请求，axios支持，通过axios.all和axios.spread实现
（5）axios支持防止CSRF攻击，通过配置
等等  

16. 浏览器有多个请求的网络情况

HTTP1.1一个tcp连接可以有多个http请求，但是这些请求是串行的，当有多个http请求时，为了尽可能不被阻塞，浏览器是可以建立多条tcp连接的。如Chrome对于同一个Host，最多可以建立6条tcp连接。

17. 为什么要进行三次握手？三次握手的作用是什么？

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

18. 为什么要四次挥手？

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。