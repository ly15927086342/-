Author: _Yu Li_  
date: _2020/04/17_  
  
# 框架相关总结  
  
## 题目  
  
1. MVVM Model-View-ViewModel  
React不是MVVM，Vue和Angular是MVVM  
优点：1. View Model同步，双向绑定 2. 关注数据，不关心同步  
缺点：1. 大型项目，ViewModel冗杂，维护成本高 2. 数据绑定没法debug  
![/static/imgs/MVVM理解导图.png](/static/imgs/MVVM理解导图.png)  
  
Vue 数据劫持，Object.defineProperty()，详见<a href="/Vue底层/wue-learn">/Vue底层/wue-learn</a>

Angular 脏检查  
Knockout 发布订阅  
  
2. 发布订阅消息模式  
发布 publish  
订阅 subscribe  
最简单的例子：Vue组件传值  
```javascript  
let bus = new Vue();  
Vue.prototype.bus = bus;  
this.bus.emit('funcName',parm);  
this.bus.on('funcName'，回调);  
```  
与观察者模式区别：  
1.Observer模式（针对对象）  
指函数自动观察数据对象，一旦对象有变化，会自动执行，实现方法Proxy+Reflect或defineProperty。详见<a href="/js原理/观察者模式.js">/js原理/观察者模式.js</a>

2.发布订阅模式（针对事件）  
emit发布  
on订阅  
once订阅一次  
remove取消订阅  
publisher发布[thingA,thingB...]触发subscriber订阅事件的回调函数[funcA,funcB,...]  
详见<a href="/js原理/发布订阅模式.js" target="_blank">/js原理/发布订阅模式.js</a>  
  
3. Vue的 computed 与 watch 异同  
computed：内部有属性改变，触发，没有改变，读取缓存。可以多个属性影响一个属性  
watch：监听data，监听对象要用深度监听，默认第一次不监听：immediate:false  
  
4. Vue深入响应式原理  
数据改变，加入队列，多次改变取最新的一个，下一次事件循环tick（nextTick）会对新旧VNode做diff，然后统一渲染变化的节点  
![/static/imgs/Vue响应机制.png](/static/imgs/Vue响应机制.png)  
  
5. Vue-router  
路由绑定组件，监听路由变化，渲染指定组件  
详见<a href="/Vue底层/Vue路由原理.html" target="_blank">/Vue底层/Vue路由原理.html</a>  
  
6. Vue生命周期钩子 
![/static/imgs/vue生命周期.png](/static/imgs/vue生命周期.png)

beforeCreate->created  
->beforeMount->mounted  
->beforeUpdate->updated  
->beforeDestroy->destroyed  
  
7. Virtual DOM(JS和DOM引擎是独立的)  
VD是简单JS对象，最少包含3个属性：tag\props\children  
VD与DOM一一对应，由HTML生成  
作用：将页面状态抽象成JS对象，配合不同渲染工具，可跨平台渲染，不会立即回流重绘，会与内存比较，一次性更新，提高页面渲染速度  
`VD如何生成真实DOM？`  
JSX编译器将HTML转为函数形式（h函数）  
h函数（hyperscript）是生成HTML的脚本（生成虚拟DOM），作用类似createElement（真实DOM）  
```javascript  
//Vue中  
render:function(h){return h(App)}  
等价于  
render:h=>h(App)  
//完整版有三个参数  
render(h) {  
	return h('div', {}, [...])  
}  
// 第一种是元素的类型（这里显示为 div）。  
// 第二个是数据对象。 我们在这里主要包括：props, attrs, dom props, class 和 style。  
// 第三个是一组子节点。 然后，我们将嵌套调用并最终返回一个虚拟DOM节点树。  
```  
VD递归->如果是string或number直接doc.createTextNode->doc.createElement(tag)->doc.setAtrribute(props)->children.map(createElement).forEach(element.appendChild.bind(element))->return element  
  
8. diff方法（简化）  
diff(oldNode,newNode)  
返回比较结果对象patch  
```javascript  
patch = {  
	type, // 1.create 2.remove 3.replace 4.update(update和replace区别是replace是类型、标签改变等)  
	vdom, // VNode  
	props:[{  
		type, // 1.remove 2.update  
		key,  
		value  
		}],  
	children:[patch,...]  
}  
```  
思路：1.state改变，生成新的VD 2.比较新旧VD异同 3.生成差异对象patch 4.遍历patch，更新DOM  
VD的优势在于，减少了渲染事件  
劣势在于，增加了JS计算事件  
在DOM比较复杂的情况下，VD的优势比较明显

9. 微信小程序原理
[https://segmentfault.com/a/1190000018631528](https://segmentfault.com/a/1190000018631528)  
小程序通信模型如图：  
![/static/imgs/小程序通信.png](/static/imgs/小程序通信.png)  
WXML模板和WXSS样式工作在渲染层WebView，JS脚本工作在逻辑层JsCore，分别由两个线程管理。  
渲染层存在多个WebView线程，线程间通信经过客户端做中转；  
逻辑层发送网络请求也经由Native转发。  
通过setData方法，把数据从逻辑层传递到渲染层，经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。  

事件处理：通过事件捕获和事件冒泡，通过native传给JSCore。

数据通信：

由于是双线程模型，需要保证时序正确。  
小程序生命周期中，存在若干次页面数据通信，逻辑层向视图层发送页面数据，视图层向逻辑层反馈用户事件。  
![/static/imgs/小程序渲染生命周期.png](/static/imgs/小程序渲染生命周期.png)

缓存机制：每个小程序缓存空间上线10MB，如果到达10MB，再调用setStorage会触发fail回调

10. 小程序为什么要设计双线程？
主要还是处于管控和安全上的考虑。我们需要阻止开发者使用一些浏览器提供的，诸如跳转页面、操作DOM、动态执行脚本的开放性接口。同时不会阻塞渲染

11. 小程序为什么使用Hybrid的渲染方式？
小程序考虑到了原生开发和纯web开发的不利之处：用纯客户端原生技术来编写小程序的话，小程序代码需要与微信代码`一起编包`，显然过于`繁重`了；而用纯Web技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些`性能`问题。

因此，小程序选择了`Hybrid`的渲染方式，将UI渲染跟JavaScript的脚本执行分在了两个线程，巧妙了解决了上述问题，作为一种全新的前端开发框架能够很快成为许多开发者的最爱也就不足为奇了。

总结，视图层用Web渲染为主，原生渲染为辅，逻辑层用JSCore

12. 微信小程序生命周期
![/static/imgs/小程序生命周期.png](/static/imgs/小程序生命周期.png)

onLoad>onShow>onReady>onHide>onUnload

~~13. Vue生命周期~~

14. Vue相比jQuery优势？

不需要手动操作DOM节点来更新视图，只需要修改数据即可。  
jQuery把Model和View-Model写在一起，太复杂。  
jQuery没有对修改数据做diff，多次更新视图，渲染效率低。  

15. MVC、MVP、MVVM区别？

[https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html](https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)

MVC是单向，View>Controller>Model>View  
MVP是双向，View>Presenter>View, Presenter>Model>Presenter  
MVVM是双向，View<>ViewModel<>Model

MVP和MVVM区别在于，MVP是双向通信（主动），而MVVM是双向绑定（监听）

16. Vue3.0有哪些新特性？

（1）更快  
虚拟DOM重写  
静态树提升（跳过修补整棵树，从而降低渲染成本）  
静态属性提升（跳过不会改变节点的修补过程，但是它的子组件会保持修补过程）  
Proxy替代Object.defineProperty，节省内存开销，但浏览器可能不兼容(ie11)  

（2）更小  
更友好的tree-shaking  
core runtime压缩后10kb  

（3）更易于维护  
Flow->TypeScript  
包的解耦  
编译器重写  

（4）更多的原生支持  
运行时内核也将与平台无关，使得Vue可以更容易地与任何平台（例如Web，iOS或Android）一起使用

（5）更易于开发使用  
暴露响应式的api，如  

```javascript
import {observable, effect} from 'vue'
const state = observable({
	count:0
})
effect(()=>{
	console.log(`count is: ${state.count}`)
}) // count is: 0
state.count++ // count is: 1
```

轻松识别组件重新渲染的原因  
```javascript
const Comp = {
	render(props){
		return h('div',props.count)
	},
	renderTriggered(event){
		debugger
	}
}
```
提供对TypeScript的支持（TSX）   

17. TypeScript和JavaScript区别？

TypeScript是ECMAScript 2015的语法超集，是JavaScript的语法糖。JavaScript程序可以直接移植到TypeScript，TypeScript需要编译（语法转换）生成JavaScript才能被浏览器执行。一图胜千言：  
![/static/imgs/typescript.jpg](/static/imgs/typescript.jpg)

静态类型语言和动态类型语言得核心区别在于，静态类型语言（statically-typed languages）会在编译时（compile time）进行类型检查，而动态语言（dynamically-typed）则是在运行时进行类型检查（runtime）。

18. 为什么Vue的data必须是一个函数，而不能是对象

对于组件而言，如果是对象，那么每个组件实例的data属性都是共享的（引用），无法复用。而用函数的话，每个实例的data都是独立的。

对于根示例而言，由于不存在复用情况，所以用对象是可行的

19. React生命周期
![/static/imgs/react生命周期.png](/static/imgs/react生命周期.png)

20. Vue和React差异
（1）数据是否可变  
React整体是函数式思想，数据不可变，单向数据流，意思就是数据改变之后布局不会自动更新，必须通过api来触发（shouldComponentUpdate()）  
Vue是响应式的，数据可变，双向绑定，通过对每一个属性添加Watcher监听数据变化，自动更新视图  
（2）生命周期不同  
React的生命周期见19，Vue的生命周期见6  
其中，React中render()函数中，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。  
（3）JSX和模板  
react：  
HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写  
vue：  
Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。  
（4）组件作用域内的css  
Vue: scoped  
React: import或class对象形式  
（5）组件传值  
React: props和callback函数  
Vue: props和emit函数，需要声明  